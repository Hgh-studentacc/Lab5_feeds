#print plots for both distance type
print(p4_s1_crit)
print(p4_s1_crit_HC)
#print(p4_s2_crit)
print(p4_s1);
#print(p4_s2)
knitr::opts_chunk$set(echo = TRUE)
#rm(list=ls())
library(ggplot2)
library(gridExtra)
library(grid)
library(plotly)
library(shiny)
library(tidyverse)
library(seriation)
Main_data.frame=read.table("prices-and-earnings.txt", header = TRUE, sep = "\t",check.names = FALSE)
Main_data.frame=tibble(Main_data.frame)
data.frameR=Main_data.frame %>% select(1,2,5,6,7,9,10,16,17,18,19)
data.frameR_scaled=scale(data.frameR[2:11])
rownames(data.frameR_scaled)=data.frameR[[1]]
p1_s1=plot_ly(x=colnames(data.frameR_scaled), y=rownames(data.frameR_scaled),
z=data.frameR_scaled, type="heatmap", colors =colorRamp(c("yellow", "red")))
p1_s1
Auto_ordering=function(Data,m){ #euc or cory
if (m=="euc"){
distrow=dist(Data, method ="euclidean")
distcol=dist(t(Data), method ="euclidean")
} else {
distrow=as.dist(1-cor(Data))   ##we need to convert the data type to dist class
distcol=as.dist(1-cor(t(Data)))
swap=distrow
distrow=distcol
distcol=swap
}
order_s1<-seriate(distrow, "HC")
order_s2<-seriate(distcol, "HC")
ord1<-get_order(order_s1)
ord2<-get_order(order_s2)
reordmatr<-Data[rev(ord1),ord2]
return(plot_ly(x=colnames(reordmatr), y=rownames(reordmatr),
z=reordmatr, type="heatmap", colors =colorRamp(c("yellow", "red"))))
}
p3_s1=Auto_ordering(data.frameR_scaled,"euc")
p3_s2=Auto_ordering(data.frameR_scaled,"noeuc")
#grid.arrange(grobs=list(p3_s1,p3_s2),nrow=2,ncol = 1)
print(p3_s1);print(p3_s2) ##ask about grid extra strange problem
Auto_ordering_4_HC=function(Data,m){ #euc or cory #function(Data,m,solver)
if (m=="euc"){
distrow=dist(Data, method ="euclidean")
distcol=dist(t(Data), method ="euclidean")
} else {
distrow=as.dist(1-cor(Data))   ##we need to convert the data type to dist class
distcol=as.dist(1-cor(t(Data)))
swap=distrow
distrow=distcol
distcol=swap
}
order_s1<-seriate(distrow,"HC") #solver)
order_s2<-seriate(distcol,"HC") #solver)
ord1<-get_order(order_s1)
ord2<-get_order(order_s2)
reordmatr<-Data[rev(ord1),ord2]
return(criterion(x=distrow,order=ord1))
}
Auto_ordering_4=function(Data,m){ #euc or cory #function(Data,m,solver)
if (m=="euc"){
distrow=dist(Data, method ="euclidean")
distcol=dist(t(Data), method ="euclidean")
} else {
distrow=as.dist(1-cor(Data))   ##we need to convert the data type to dist class
distcol=as.dist(1-cor(t(Data)))
swap=distrow
distrow=distcol
distcol=swap
}
order_s1<-seriate(distrow,"TSP") #solver)
order_s2<-seriate(distcol,"TSP") #solver)
ord1<-get_order(order_s1)
ord2<-get_order(order_s2)
reordmatr<-Data[rev(ord1),ord2]
return(list(plot_ly(x=colnames(reordmatr), y=rownames(reordmatr),
z=reordmatr, type="heatmap", colors =colorRamp(c("yellow", "red"))),criterion(x=distrow,order=ord1)))
}
p4_s1=Auto_ordering_4(data.frameR_scaled,m="euc")[[1]]
p4_s1_crit=Auto_ordering_4(data.frameR_scaled,m="euc")[[2]]
p4_s1_crit_HC=Auto_ordering_4_HC(data.frameR_scaled,m="euc")
#p4_s2=Auto_ordering_4(data.frameR_scaled,m="noeuc")[[1]]
#p4_s2_crit=Auto_ordering_4(data.frameR_scaled,m="noeuc")[[2]]
#print plots for both distance type
print(p4_s1_crit)
print(p4_s1_crit_HC)
#print(p4_s2_crit)
print(p4_s1);
#print(p4_s2)
for (i in 1:length(colnames(data.frameR_scaled))){
colnames(data.frameR_scaled)[[i]]=gsub(' ','',colnames(data.frameR_scaled)[[i]])
}
colnames(data.frameR_scaled)[[10]]="GoodsandServices"
colnames(data.frameR_scaled)[[1]]="FoodCosts"
colnames(data.frameR_scaled)[[2]]="iPhone4S"
colnames(data.frameR_scaled)[[7]]="BigMac"
colnames(data.frameR_scaled)[[8]]="Bread"
colnames(data.frameR_scaled)[[9]]="Rice"
dims_p5=list()
for( i in 1:ncol(data.frameR_scaled)){
dims_p5[[i]]=list( label=colnames(data.frameR_scaled)[i],
values=as.formula(paste("~",colnames(data.frameR_scaled)[i])))
}
data.frameR_scaled=as.data.frame(data.frameR_scaled)
p5_s1=plot_ly(data=data.frameR_scaled,type = 'parcoords',
dimensions = dims_p5
)
print(p5_s1)
p5_s2=plot_ly(data=data.frameR_scaled,type = 'parcoords',
dimensions = dims_p5,
line=list(color = abs(data.frameR_scaled[["iPhone4S"]]))
)
print(p5_s2)
HC_order=function(Data){ #euc or cory
distrow=dist(Data, method ="euclidean")
distcol=dist(t(Data), method ="euclidean")
order_s1<-seriate(distrow, "HC")
order_s2<-seriate(distcol, "HC")
ord1<-get_order(order_s1)
ord2<-get_order(order_s2)
return(reordmatr<-Data[rev(ord1),ord2])
}
P6=HC_order(data.frameR_scaled)
Ps=list()
nPlot=nrow(data.frameR_scaled)
for (i in 1:nPlot){
Ps[[i]] <- htmltools::tags$div(
plot_ly(type = 'scatterpolar',
r=as.numeric(P6[i,-1]),
theta= colnames(P6)[-1],
fill="toself")%>%
layout(title=rownames(data.frameR_scaled)[i]), style="width: 25%;")
}
p6_s1 =htmltools::tags$div(style = "display: flex; flex-wrap: wrap", Ps)
htmltools::browsable(p6_s1)
dataframe_p2=read.csv("adult.csv",sep = ",",header = FALSE)
colnames(dataframe_p2)=c("age","workclass","fnlwgt","education","education-num","marital-status","occupation","relationship","race","sex","capital-gain","capital-loss","hours-per-week","native-country","Income level")
p21_s1=ggplot()+
geom_point(data=dataframe_p2,aes(x=.data[["age"]],y=.data[["hours-per-week"]],color=.data[["Income level"]]))
p21_s2=ggplot()+
geom_point(data=dataframe_p2,aes(x=.data[["age"]],y=.data[["hours-per-week"]],color=.data[["Income level"]]))+
facet_grid(rows=.~dataframe_p2[[15]])
print(p21_s1)
print(p21_s2)
p22_s1=ggplot() +
geom_density(data=dataframe_p2, aes(x = .data[["age"]],color=.data[[15]]))
gr_table=dataframe_p2[dataframe_p2[["capital-loss"]]!=0,]
p23_s1=plot_ly(gr_table, x = gr_table[["education-num"]], y = gr_table[["age"]], z = gr_table[["capital-loss"]])
print(p23_s1)
#cut to 6 pieces
p23_s2=ggplot() +
geom_density_2d(data=gr_table, aes(x = gr_table[["education-num"]], y = gr_table[["capital-loss"]]))+
facet_grid(rows=cut_number(gr_table[["age"]],n=6))
print(p23_s2)
#using cut_number
p24_s1=ggplot() +
geom_point(data=dataframe_p2, aes(x = dataframe_p2[["education-num"]], y = dataframe_p2[["capital-loss"]]))+
facet_grid(rows=cut_number(dataframe_p2[["age"]],n=4))
print(p24_s1)
#using Shingles
Agerange<-lattice::equal.count(dataframe_p2[["age"]], number=4, overlap=0.1) #overlap is 10%
L=matrix(unlist(levels(Agerange)), ncol=2, byrow = T)
L1=data.frame(Lower=L[,1],Upper=L[,2], Interval=factor(1:nrow(L)))
index=c()
Class=c()
for(i in 1:nrow(L)){
Cl=paste("[", L1$Lower[i], ",", L1$Upper[i], "]", sep="")
ind=which(dataframe_p2[["age"]]>=L1$Lower[i] & dataframe_p2[["age"]]<=L1$Upper[i])
index=c(index,ind)
Class=c(Class, rep(Cl, length(ind)))
}
df4<-dataframe_p2[index,]
df4$Class<-as.factor(Class)
p24_s2=ggplot() +
geom_point(data=df4, aes(x = df4[["education-num"]], y = df4[["capital-loss"]]))+
facet_wrap(~Class, labeller = "label_both")
print(p24_s2)
p4_s1_crit
p4_s1_crit_HC
p3_s1
1.695736e+05<7.046310e+04
1.695736e+05>7.046310e+04
7.434000e+04>3.098000e+04
p5_s1
p5_s2
htmltools::browsable(p6_s1)
gc()
n
#rm(list=ls())
library(httr)
library(shiny)
# url <- "https://weatherapi-com.p.rapidapi.com/future.json"
#
# queryString <- list(
#   q = "London",
#   dt = "2022-12-25"
# )
#
# response <- VERB("GET", url, add_headers('X-RapidAPI-Key' = 'SIGN-UP-FOR-KEY', 'X-RapidAPI-Host' = 'weatherapi-com.p.rapidapi.com'), query = queryString, content_type("application/octet-stream"))
#
# content(response, "text")
#
# #realtime weather
# url <- "https://weatherapi-com.p.rapidapi.com/current.json"
#
# queryString <- list(q = "<REQUIRED>")
#
# response <- VERB("GET", url, add_headers('X-RapidAPI-Key' = 'SIGN-UP-FOR-KEY', 'X-RapidAPI-Host' = 'weatherapi-com.p.rapidapi.com'), query = queryString, content_type("application/octet-stream"))
#
# content(response, "text")
#History weather
url <- "http://api.kolada.se/v2/data/kpi/N00945/year/2009"
resp_test = GET(url)
if (http_type(resp_test) != "application/json") {
stop("API did not return json", call. = FALSE)
}
print(resp_test)
# queryString <- list(
#   kpi = "",
#   dt = "<REQUIRED>",
#   next_page = "en"
# )
#
# response <- VERB("GET", url, add_headers(), query = queryString, content_type("application/json"))
#
# content(response, "text")
View(resp_test)
resp_test$headers
resp_test$headers()
resp_test$content
View(resp_test)
#rm(list=ls())
library(httr)
library(shiny)
# url <- "https://weatherapi-com.p.rapidapi.com/future.json"
#
# queryString <- list(
#   q = "London",
#   dt = "2022-12-25"
# )
#
# response <- VERB("GET", url, add_headers('X-RapidAPI-Key' = 'SIGN-UP-FOR-KEY', 'X-RapidAPI-Host' = 'weatherapi-com.p.rapidapi.com'), query = queryString, content_type("application/octet-stream"))
#
# content(response, "text")
#
# #realtime weather
# url <- "https://weatherapi-com.p.rapidapi.com/current.json"
#
# queryString <- list(q = "<REQUIRED>")
#
# response <- VERB("GET", url, add_headers('X-RapidAPI-Key' = 'SIGN-UP-FOR-KEY', 'X-RapidAPI-Host' = 'weatherapi-com.p.rapidapi.com'), query = queryString, content_type("application/octet-stream"))
#
# content(response, "text")
#History weather
url <- "http://api.kolada.se/v2/data/kpi/N00945/year/2009"
resp_test = GET(url)
if (http_type(resp_test) != "application/json") {
stop("API did not return json", call. = FALSE)
}
#print(resp_test)
# queryString <- list(
#   kpi = "",
#   dt = "<REQUIRED>",
#   next_page = "en"
# )
#
# response <- VERB("GET", url, add_headers(), query = queryString, content_type("application/json"))
#
content(resp_test, "text")
#rm(list=ls())
library(httr)
library(shiny)
# url <- "https://weatherapi-com.p.rapidapi.com/future.json"
#
# queryString <- list(
#   q = "London",
#   dt = "2022-12-25"
# )
#
# response <- VERB("GET", url, add_headers('X-RapidAPI-Key' = 'SIGN-UP-FOR-KEY', 'X-RapidAPI-Host' = 'weatherapi-com.p.rapidapi.com'), query = queryString, content_type("application/octet-stream"))
#
# content(response, "text")
#
# #realtime weather
# url <- "https://weatherapi-com.p.rapidapi.com/current.json"
#
# queryString <- list(q = "<REQUIRED>")
#
# response <- VERB("GET", url, add_headers('X-RapidAPI-Key' = 'SIGN-UP-FOR-KEY', 'X-RapidAPI-Host' = 'weatherapi-com.p.rapidapi.com'), query = queryString, content_type("application/octet-stream"))
#
# content(response, "text")
#History weather
url <- "http://api.kolada.se/v2/data/kpi/N00945/year/2009"
resp_test = GET(url)
if (http_type(resp_test) != "application/json") {
stop("API did not return json", call. = FALSE)
}
#print(resp_test)
# queryString <- list(
#   kpi = "",
#   dt = "<REQUIRED>",
#   next_page = "en"
# )
#
# response <- VERB("GET", url, add_headers(), query = queryString, content_type("application/json"))
#
a=content(resp_test, "text")
#rm(list=ls())
library(httr)
library(jsonlite)
library(shiny)
# url <- "https://weatherapi-com.p.rapidapi.com/future.json"
#
# queryString <- list(
#   q = "London",
#   dt = "2022-12-25"
# )
#
# response <- VERB("GET", url, add_headers('X-RapidAPI-Key' = 'SIGN-UP-FOR-KEY', 'X-RapidAPI-Host' = 'weatherapi-com.p.rapidapi.com'), query = queryString, content_type("application/octet-stream"))
#
# content(response, "text")
#
# #realtime weather
# url <- "https://weatherapi-com.p.rapidapi.com/current.json"
#
# queryString <- list(q = "<REQUIRED>")
#
# response <- VERB("GET", url, add_headers('X-RapidAPI-Key' = 'SIGN-UP-FOR-KEY', 'X-RapidAPI-Host' = 'weatherapi-com.p.rapidapi.com'), query = queryString, content_type("application/octet-stream"))
#
# content(response, "text")
#History weather
url <- "http://api.kolada.se/v2/data/kpi/N00945/year/2009"
resp_test = GET(url)
if (http_type(resp_test) != "application/json") {
stop("API did not return json", call. = FALSE)
}
#print(resp_test)
# queryString <- list(
#   kpi = "",
#   dt = "<REQUIRED>",
#   next_page = "en"
# )
#
# response <- VERB("GET", url, add_headers(), query = queryString, content_type("application/json"))
#
a=content(resp_test)
View(a)
a$values[[1]]
KoladaAPI=function(){
#rm(list=ls())
library(httr)
library(readxl)
#library(jsonlite) #just for test comments
List_kommun = read_excel("List_kommun.xlsx",col_types = "text")
rich=c(28,121,235,252,26,151,129,251,199,32,261,125)
richnames=List_kommun$Kommun[c(29,122,236,253,27,152,130,252,200,33,262,126)-1]
richcode=List_kommun$Kod[c(29,122,236,253,27,152,130,252,200,33,262,126)-1]
url=list()
for (i in rich){
url[[i]] =gsub("[\r\n]", "", paste("http://api.kolada.se/v2/data/kpi/N03101,N03006,N03105,N03120,N03104,N03132,N03100,N03048,N03001,N03003,N03103,N03016,N03016,N03106,N03144,N03079,N03102/municipality/",List_kommun$Kod[i],"/year/2000,2001,2002,2003,2004,2005,2006,2007,2008,2009,
2010,2011,2012,2013,2014,2015,2016,2017,2018,2019,2020,2021",sep = ""))
}
url[sapply(url, is.null)] <- NULL
resp_test=lapply(url,GET)
data_cont=lapply(resp_test,content)
##Here we create a big list out of values in data_cont(and its sub_list)
list_adder=function(n){
return(data_cont[[n]]$values)
}
list_extract=function(n,m){
dot=my_data[[n]][[m]][1:3]
dot=append(dot,my_data[[n]][[m]][[4]][[1]][4])
return(dot)
}
## after making the big list we create sub list out of that for preparation
#of dataframe
my_data=(lapply(1:length(data_cont),list_adder))  #list of raw data
##following function creates final list
f_list=list()
for (i in 1:length(my_data)){
for (j in 1:160){
f_list=append(f_list,list(list_extract(i,j)))
}
}
return(f_list)
}
#plot all functions using corresponding names
plotfunction_ind=function(){
library(shiny)
library(readxl)
library(ggplot2)
List_kommun = read_excel("List_kommun.xlsx",col_types = "text")
List_factors = read_excel("factors.xlsx",col_types = "text",col_names=FALSE)
outlist=KoladaAPI()
da=matrix(outlist[[1]],ncol=4)
colnames(da)=names(outlist[[1]])
for (i in 2:length(outlist)){da=rbind(da,(outlist[[i]]))}
da=as.data.frame(da)
ui <- fluidPage(checkboxGroupInput(inputId="factors", label="Choose economic factor variable", choices = NULL,
inline = FALSE, width = NULL, choiceNames = List_factors[[2]],
choiceValues = List_factors[[1]]),
checkboxGroupInput(inputId="Municipalities", label="Choose city variable", choices = NULL,
inline = FALSE, width = NULL, choiceNames = List_kommun$Kommun[c(29,122,236,253,27,152,130,252,200,33,262,126)-1],
choiceValues = List_kommun$Kod[c(29,122,236,253,27,152,130,252,200,33,262,126)-1]),
plotOutput("densPlot"))
server <- function(input, output) {
output$densPlot <- renderPlot({
first_filter=da[da[["kpi"]]==input$factors,]
second_filter=first_filter[first_filter[["municipality"]]==input$Municipalities,]
mufflin=ggplot(data=second_filter,aes(x=unlist(.data$period),y=unlist(.data[["value"]])))+
geom_point()+
geom_line()+
xlab("period")+
ylab(paste(List_factors[[2]][List_factors[[1]]==input$factors]))
print(mufflin)
#print(input$Municipalities)
print(first_filter)
print(second_filter)
})
}
# Run the application
shinyApp(ui = ui, server = server)
}
plotfunction_ind()
setwd("E:/Git F/R-student1/Lab5_project")
plotfunction_ind()
#plot all functions using corresponding names
plotfunction_ind=function(){
}
library(shiny)
library(readxl)
library(ggplot2)
List_kommun = read_excel("List_kommun.xlsx",col_types = "text")
List_factors = read_excel("factors.xlsx",col_types = "text",col_names=FALSE)
outlist=KoladaAPI()
da=matrix(outlist[[1]],ncol=4)
colnames(da)=names(outlist[[1]])
for (i in 2:length(outlist)){da=rbind(da,(outlist[[i]]))}
da=as.data.frame(da)
ui <- fluidPage(checkboxGroupInput(inputId="factors", label="Choose economic factor variable", choices = NULL,
inline = FALSE, width = NULL, choiceNames = List_factors[[2]],
choiceValues = List_factors[[1]]),
checkboxGroupInput(inputId="Municipalities", label="Choose city variable", choices = NULL,
inline = FALSE, width = NULL, choiceNames = List_kommun$Kommun[c(29,122,236,253,27,152,130,252,200,33,262,126)-1],
choiceValues = List_kommun$Kod[c(29,122,236,253,27,152,130,252,200,33,262,126)-1]),
plotOutput("densPlot"))
server <- function(input, output) {
output$densPlot <- renderPlot({
first_filter=da[da[["kpi"]]==input$factors,]
second_filter=first_filter[first_filter[["municipality"]]==input$Municipalities,]
mufflin=ggplot(data=second_filter,aes(x=unlist(.data$period),y=unlist(.data[["value"]])))+
geom_point()+
geom_line()+
xlab("period")+
ylab(paste(List_factors[[2]][List_factors[[1]]==input$factors]))
print(mufflin)
#print(input$Municipalities)
print(first_filter)
print(second_filter)
})
}
# Run the application
shinyApp(ui = ui, server = server)
runApp('Shiny_plots.R')
#plot all functions using corresponding names
plotfunction_ind=function(){
shinyApp(ui = ui, server = server)
}
library(shiny)
library(readxl)
library(ggplot2)
List_kommun = read_excel("List_kommun.xlsx",col_types = "text")
List_factors = read_excel("factors.xlsx",col_types = "text",col_names=FALSE)
outlist=KoladaAPI()
da=matrix(outlist[[1]],ncol=4)
colnames(da)=names(outlist[[1]])
for (i in 2:length(outlist)){da=rbind(da,(outlist[[i]]))}
da=as.data.frame(da)
ui <- fluidPage(checkboxGroupInput(inputId="factors", label="Choose economic factor variable", choices = NULL,
inline = FALSE, width = NULL, choiceNames = List_factors[[2]],
choiceValues = List_factors[[1]]),
checkboxGroupInput(inputId="Municipalities", label="Choose city variable", choices = NULL,
inline = FALSE, width = NULL, choiceNames = List_kommun$Kommun[c(29,122,236,253,27,152,130,252,200,33,262,126)-1],
choiceValues = List_kommun$Kod[c(29,122,236,253,27,152,130,252,200,33,262,126)-1]),
plotOutput("densPlot"))
server <- function(input, output) {
output$densPlot <- renderPlot({
first_filter=da[da[["kpi"]]==input$factors,]
second_filter=first_filter[first_filter[["municipality"]]==input$Municipalities,]
mufflin=ggplot(data=second_filter,aes(x=unlist(.data$period),y=unlist(.data[["value"]])))+
geom_point()+
geom_line()+
xlab("period")+
ylab(paste(List_factors[[2]][List_factors[[1]]==input$factors]))
print(mufflin)
#print(input$Municipalities)
print(first_filter)
print(second_filter)
})
}
# Run the application
#shinyApp(ui = ui, server = server)
View(plotfunction_ind)
function(){
shinyApp(ui = ui, server = server)
}
plotfunction_ind()
